#!/usr/bin/env python3
"""Simple Bluetooth device connection script."""

import subprocess
import sys
import time
import re


def run_command(cmd, timeout=5):
    """Run a shell command and return output."""
    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return result.stdout, result.stderr, result.returncode
    except subprocess.TimeoutExpired:
        return "", "Command timed out", 1


def notify(title, message, urgency="normal"):
    """Send desktop notification."""
    run_command(f'notify-send -u {urgency} "{title}" "{message}"')


def bluetoothctl_connect(mac):
    """Send connect command to bluetoothctl."""
    cmd = f'printf "connect {mac}\\nexit\\n" | bluetoothctl'
    stdout, stderr, code = run_command(cmd)
    return code == 0


def check_connected(mac, max_attempts=6, interval=0.5):
    """Poll bluetoothctl to verify device is connected."""
    for attempt in range(max_attempts):
        stdout, _, _ = run_command(f'bluetoothctl info "{mac}"', timeout=3)

        match = re.search(r'Connected:\s+(\w+)', stdout)
        if match and match.group(1).lower() == 'yes':
            return True

        if attempt < max_attempts - 1:
            time.sleep(interval)

    return False


def find_sink(mac, max_attempts=6, interval=0.5):
    """Poll for PulseAudio/PipeWire sink to appear."""
    sink_part = mac.replace(':', '_')

    for attempt in range(max_attempts):
        stdout, _, _ = run_command('pactl list short sinks', timeout=3)

        for line in stdout.split('\n'):
            if sink_part in line:
                parts = line.split()
                if len(parts) >= 2:
                    return parts[1]

        if attempt < max_attempts - 1:
            time.sleep(interval)

    return None


def set_default_sink(sink_name):
    """Set the default audio sink and move existing streams."""
    _, _, code = run_command(f'pactl set-default-sink "{sink_name}"')
    if code != 0:
        return False

    stdout, _, _ = run_command('pactl list short sink-inputs')
    for line in stdout.split('\n'):
        if line.strip():
            stream_id = line.split()[0]
            run_command(f'pactl move-sink-input {stream_id} "{sink_name}"')

    return True


def refresh_dwmblocks(signal):
    """Refresh dwmblocks status bar."""
    run_command(f'pkill -RTMIN+{signal} dwmblocks')
    run_command('pkill -RTMIN+4 dwmblocks')


def main():
    if len(sys.argv) != 4:
        print("Usage: bt-connect MAC SIGNAL NAME")
        print("Example: bt-connect '3C:B0:ED:A7:6A:88' 3 'Nothing Headphone (1)'")
        sys.exit(1)

    mac = sys.argv[1]
    signal = sys.argv[2]
    name = sys.argv[3]

    print(f"Connecting to {name}...")

    # Step 1: Send connect command
    bluetoothctl_connect(mac)

    # Step 2: Verify connection (max 3 seconds)
    if not check_connected(mac):
        msg = f"Failed to connect to {name}"
        print(f"Error: {msg}")
        notify("Bluetooth Connection Failed", msg)
        sys.exit(1)

    # Step 3: Wait for audio sink (max 3 seconds)
    sink = find_sink(mac)
    if not sink:
        msg = f"Sink for {name} not found"
        print(f"Error: {msg}")
        notify("Bluetooth Sink Error", msg)
        sys.exit(1)

    # Step 4: Set as default
    if not set_default_sink(sink):
        msg = f"Failed to set {name} as default sink"
        print(f"Error: {msg}")
        notify("Bluetooth Sink Error", msg)
        sys.exit(1)

    print(f"âœ“ {name} connected")
    notify("Bluetooth Connected", name, "normal")

    # Refresh status bar
    refresh_dwmblocks(signal)
    refresh_polybar()


def refresh_polybar():
    """Trigger Polybar updates for bluetooth modules."""
    # Trigger IPC hooks twice: immediate feedback and delayed update for battery
    modules = ["headphones", "miniroll", "musicozy"]
    for module in modules:
        run_command(f"polybar-msg action {module} hook 0")

    time.sleep(1)
    for module in modules:
        run_command(f"polybar-msg action {module} hook 0")


if __name__ == "__main__":
    main()
