#!/usr/bin/env python3
import subprocess
import json
import sys
import shutil
import os

"""Manage USB drives via rofi and udisksctl."""

class UsbManager:
    def notify(self, message):
         subprocess.run(["notify-send", "USB", message])

    def get_partitions(self):
        try:
            # Use lsblk with JSON output for robust parsing
            # -J: json, -p: full paths, -o: output columns
            cmd = ["lsblk", "-Jpo", "NAME,TYPE,MOUNTPOINT,SIZE,LABEL,RM"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            data = json.loads(result.stdout)
            
            partitions = []
            
            # recursive function to flatten if needed, but -o usually gives flat list of block devices?
            # lsblk -J hierarchy can be nested.
            
            def extract_partitions(devices):
                for dev in devices:
                     # Check if partition and removable
                     # Note: lsblk JSON 'rm' is boolean true/false or string "1"/"0"?
                     # Usually boolean in recent versions, but safe to check truthiness.
                     
                     is_removable = dev.get("rm")
                     # Sometimes 'rm' is string "1"
                     if isinstance(is_removable, str):
                         is_removable = (is_removable == "1")
                     
                     if dev.get("type") == "part" and is_removable:
                         partitions.append(dev)
                     
                     if "children" in dev:
                         extract_partitions(dev["children"])

            if "blockdevices" in data:
                extract_partitions(data["blockdevices"])
            
            return partitions
        except (subprocess.CalledProcessError, json.JSONDecodeError):
            self.notify("Error scanning devices")
            return []

    def format_partition_label(self, part):
        name = part.get("name")
        size = part.get("size")
        label = part.get("label") or "no-label"
        mountpoint = part.get("mountpoint")
        
        status = "mounted" if mountpoint else "unmounted"
        return f"{name:20}  {size:6}  {label:15}  [{status}]"

    def rofi_select(self, prompt, items):
        if not items:
            return None
        input_str = "\n".join(items)
        try:
            result = subprocess.run(
                ["rofi", "-dmenu", "-i", "-p", prompt],
                input=input_str,
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return None

    def mount(self, device):
        try:
            result = subprocess.run(
                ["udisksctl", "mount", "-b", device],
                capture_output=True,
                text=True,
                check=True
            )
            # Output: Mounted /dev/sdX1 at /media/user/Label
            output = result.stdout.strip()
            self.notify(output)
            # Try to start file manager logic? Or just notify.
            # Original script notifies "Mounted ... at ..."
            # We can extract mountpoint from output or re-query.
            # Usually strict parsing isn't needed for just notification.
            return True
        except subprocess.CalledProcessError as e:
            self.notify(f"Failed to mount {device}")
            return False

    def unmount(self, device):
        try:
            subprocess.run(
                ["udisksctl", "unmount", "-b", device],
                capture_output=True,
                check=True
            )
            self.notify(f"Unmounted {device}")
            return True
        except subprocess.CalledProcessError:
            self.notify(f"Failed to unmount {device}")
            return False

    def open_drive(self, mountpoint):
        if not mountpoint:
            self.notify("Drive not mounted")
            return
            
        if shutil.which("xdg-open"):
            subprocess.Popen(["xdg-open", mountpoint])
        elif os.environ.get("TERMINAL"):
             term = os.environ.get("TERMINAL")
             subprocess.Popen([term, "-e", "sh", "-c", f"cd '{mountpoint}' && $SHELL"])
        else:
             self.notify("No file manager found")

    def run(self):
        if not shutil.which("udisksctl"):
            self.notify("udisks2 not installed")
            sys.exit(1)

        partitions = self.get_partitions()
        if not partitions:
            self.notify("No external drives detected")
            sys.exit(0)

        # Create menu items
        # Map label string to partition object for lookup
        # BUT rofi returns string. We need to parse device name back from string.
        # Original: echo "$1" | awk '{print $1}' -> first column is name.
        
        menu_items = [self.format_partition_label(p) for p in partitions]
        
        selected = self.rofi_select("Select drive:", menu_items)
        if not selected:
            sys.exit(0)
            
        device_name = selected.split()[0]
        
        # Find the partition object again to get mountpoint
        target_part = next((p for p in partitions if p.get("name") == device_name), None)
        
        if not target_part:
            sys.exit(1)

        # Action Menu
        actions = []
        if target_part.get("mountpoint"):
            actions = ["‚èè Unmount", "üìÇ Open in file manager"]
        else:
            actions = ["üìÇ Mount"]
            
        action = self.rofi_select(f"Action for {os.path.basename(device_name)}:", actions)
        
        if not action:
            sys.exit(0)
            
        if "Mount" in action:
             self.mount(device_name)
        elif "Unmount" in action:
             self.unmount(device_name)
        elif "Open" in action:
             self.open_drive(target_part.get("mountpoint"))

if __name__ == "__main__":
    UsbManager().run()
