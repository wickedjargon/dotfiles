#!/usr/bin/env python3
import os
import sys
import subprocess
import select
import shutil

"""Battery monitor script converted to Python."""

BATTERY_PATH = "/sys/class/power_supply/BAT0"
SOUND_FILE = "/usr/share/sounds/freedesktop/stereo/suspend-error.oga"

class BatteryMonitor:
    def __init__(self):
        self.sent_10 = False
        self.sent_20 = False
        self.battery_path = BATTERY_PATH

    def notify(self, urgency, title, message, expire_time=None):
        cmd = ["notify-send", "-u", urgency, "-h", "string:x-canonical-private-synchronous:bat_alert"]
        if expire_time:
            cmd.extend(["-t", str(expire_time)])
        cmd.extend([title, message])
        subprocess.run(cmd)

    def play_sound(self):
        subprocess.Popen(["paplay", SOUND_FILE])

    def get_file_content(self, filename):
        try:
            with open(os.path.join(self.battery_path, filename), 'r') as f:
                return f.read().strip()
        except IOError:
            return None

    def check_battery(self):
        if not os.path.exists(self.battery_path):
            return

        status = self.get_file_content("status")
        capacity_str = self.get_file_content("capacity")
        
        if not status or not capacity_str:
            return

        try:
            capacity = int(capacity_str)
        except ValueError:
            return

        if status == "Discharging":
            # Critical
            if capacity <= 10 and not self.sent_10:
                self.notify("critical", "Battery Critical", f"Level is at {capacity}%.")
                self.play_sound()
                self.sent_10 = True
                self.sent_20 = True # Also silence low warning if we skipped it
            
            # Low
            elif 10 < capacity <= 20 and not self.sent_20:
                self.notify("normal", "Battery Low", f"Level is at {capacity}%.")
                self.play_sound()
                self.sent_20 = True

        else:
            # Charging or Full
            if self.sent_10 or self.sent_20:
                self.notify("low", "Charging", "Battery recovering...", expire_time=2000)
                self.sent_10 = False
                self.sent_20 = False

    def run(self):
        proc = None
        try:
            if not os.path.exists(self.battery_path):
                sys.exit(0)

            if not shutil.which("acpi_listen"):
                 self.notify("normal", "Battery Monitor", "Error: acpi_listen not found. Install 'acpid'.")
                 sys.exit(1)

            # Start acpi_listen with line buffering
            proc = subprocess.Popen(["stdbuf", "-oL", "acpi_listen"], stdout=subprocess.PIPE, text=True)

            while True:
                self.check_battery()
                
                # Wait for up to 60 seconds for output
                r, _, _ = select.select([proc.stdout], [], [], 60)
                
                if r:
                    line = proc.stdout.readline()
                    if not line:
                        break # EOF
                # Loop continues on timeout or event

        except KeyboardInterrupt:
            pass
        finally:
            if proc:
                proc.kill()

if __name__ == "__main__":
    BatteryMonitor().run()
